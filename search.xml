<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Stanford cs193p 01 | 课程简介及SwiftUI入门</title>
    <url>/2024/11/21/Stanford-cs193p-01%EF%BD%9C%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B%E5%8F%8ASwiftUI%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 01 集的相关笔记。</p>
<span id="more"></span>

<h2 id="0-课程介绍"><a href="#0-课程介绍" class="headerlink" title="0. 课程介绍"></a>0. 课程介绍</h2><blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<ul>
<li><strong>课程网址</strong>：<a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></li>
<li><strong>swift 说明文档</strong>：<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/">英文版</a> ｜ <a href="https://swift.bootcss.com/">中文版</a></li>
</ul>
<h3 id="课程要求-🎓"><a href="#课程要求-🎓" class="headerlink" title="课程要求 🎓"></a>课程要求 🎓</h3><ul>
<li>建议：具备编程经验，熟悉多种编程语言</li>
<li>备注：不具备编程经验学习具有挑战</li>
</ul>
<h3 id="学习内容-🖥️"><a href="#学习内容-🖥️" class="headerlink" title="学习内容 🖥️"></a>学习内容 🖥️</h3><ul>
<li>使用 Xcode 导航</li>
<li>理解 SwiftUI 与功能性编程的结构</li>
</ul>
<h3 id="主要项目-📚"><a href="#主要项目-📚" class="headerlink" title="主要项目 📚"></a>主要项目 📚</h3><ul>
<li>创建卡牌游戏应用 Memorize</li>
<li>动画与用户界面设计</li>
</ul>
<hr>
<h2 id="1-SwiftUI-视图构建和代码结构"><a href="#1-SwiftUI-视图构建和代码结构" class="headerlink" title="1. SwiftUI 视图构建和代码结构"></a>1. SwiftUI 视图构建和代码结构</h2><h3 id="1-1-项目准备工作"><a href="#1-1-项目准备工作" class="headerlink" title="1.1 项目准备工作"></a>1.1 项目准备工作</h3><p>熟悉 Xcode 的安装与使用。新建项目及文件，各类文件的作用与区别。</p>
<ol>
<li>新建项目：对于项目名字、组织与识别 ID 的说明。</li>
<li>配置项目属性：设置项目运行的平台有哪些。</li>
<li>新建项目时生成的各文件介绍。</li>
<li>预览代码及代码属性修改器的介绍和其它使用小技巧等。</li>
</ol>
<h3 id="1-2-实例演练"><a href="#1-2-实例演练" class="headerlink" title="1.2 实例演练"></a>1.2 实例演练</h3><p>完整的 “Hello world” 代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">        	<span class="type">Image</span>(systemName:<span class="string">&quot;globe&quot;</span>)</span><br><span class="line">        		.imageScale(.large)</span><br><span class="line">        		.foregroundStyle(.tint)</span><br><span class="line">        	<span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，将按照由上至下，由外至内的方式对这一段代码进行解释。</p>
<h4 id="1-2-1-struct-和-View"><a href="#1-2-1-struct-和-View" class="headerlink" title="1.2.1 struct 和 View"></a>1.2.1 <code>struct</code> 和 <code>View</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个 ContentView 结构体，并符合 View 协议</span></span><br><span class="line">    <span class="comment">//该结构体符合 View 协议意味着：需要提供一个变量 body</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">//some View的意思是返回行为与View相似的元素</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>struct</code> 结构体，它是 swiftUI 的核心。Swift 不是面向对象的编程语言 (Objective-oriented programming)，是函数式编程 (Functional programming)。</li>
<li><code>ContentView</code> 是结构体的名称，<code>struct ContentView: View</code> 意味着 <code>ContentView</code> 结构体像一个 <code>View</code>。</li>
<li><code>View</code> 和 <code>some View</code> 区分：此处的 View 是一个协议（protocol）。</li>
</ul>
<h4 id="1-2-2-var"><a href="#1-2-2-var" class="headerlink" title="1.2.2 var"></a>1.2.2 <code>var</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="comment">//some View的意思是返回行为与View相似的元素</span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>var</code>是一个变量的关键字，body 是变量名。其他变量可能如下所示：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span></span><br><span class="line"><span class="keyword">var</span> s: <span class="type">String</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Int</code> <code>String</code> 是 <code>struct</code> 结构体</li>
<li><code>some View</code> 是某种类型的 <code>View</code>，只要是一个 <code>View</code> 即可，比如 <code>Text</code>、<code>Image</code>、<code>VStack</code> 、<code>HStack</code> 等。</li>
</ul>
<h4 id="1-2-3-计算属性-Computed-Property"><a href="#1-2-3-计算属性-Computed-Property" class="headerlink" title="1.2.3 计算属性 Computed Property"></a>1.2.3 计算属性 <code>Computed Property</code></h4><p>上边我们解释了 <code>var body: some View</code>，接下来看 <code>body</code> 中的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	<span class="type">VStack</span> &#123;</span><br><span class="line">		<span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">			.imageScale(.large)</span><br><span class="line">			.foregroundStyle(.tint)</span><br><span class="line">		<span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	.padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>var body</code> 是一个属性，<code>body</code> 变量的值不会存储在某个地方，而是在每次程序运行时都会计算一次。在 “Hello World” 代码中，它计算的是如下部分：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">	<span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">		.imageScale(.large)</span><br><span class="line">		.foregroundStyle(.tint)</span><br><span class="line">	<span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.padding()</span><br></pre></td></tr></table></figure>

<h4 id="1-2-4-视图结构-VStack"><a href="#1-2-4-视图结构-VStack" class="headerlink" title="1.2.4 视图结构 VStack"></a>1.2.4 视图结构 <code>VStack</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">	<span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">		.imageScale(.large)</span><br><span class="line">		.foregroundStyle(.tint)</span><br><span class="line">	<span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>结构体实例</strong> (Instance of structs)：VStack 是一个 SwiftUI 中的结构体，用于垂直堆叠和排列多个子视图，例如 <code>Image</code> 和 <code>Text</code>。</li>
<li><strong>命名参数</strong> (named parameters)：<code>VStack</code> 可以接受不同的参数，默认的 <code>alignment</code> 是 <code>.center</code>，<code>spacing</code> 是 0，表示所有子视图居中对齐，且垂直间距为 0。</li>
<li><strong>参数默认值</strong> (Parameter Defaults)：<code>VStack</code> 允许指定 <code>alignment</code> 和 <code>spacing</code>，但它们有默认值，不指定时会使用默认设置。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">        .imageScale(.large)</span><br><span class="line">        .foregroundStyle(.tint)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>内容参数</strong><code>content</code>：<code>VStack</code> 实际上可以用 <code>content</code> 参数来包裹内容，SwiftUI 允许省略 <code>content:</code> 以简化语法。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span>(content: &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">        .imageScale(.large)</span><br><span class="line">        .foregroundStyle(.tint)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@ViewBuilder</strong>：<code>VStack</code> 使用 <code>@ViewBuilder</code> 属性包装器将多个子视图（如 <code>Image</code> 和 <code>Text</code>）转换为 <code>TupleView</code>。这意味着 <code>VStack</code> 可以组合多个视图，而 SwiftUI 会自动处理和渲染它们。</li>
</ul>
<h4 id="1-2-5-View-Modifier"><a href="#1-2-5-View-Modifier" class="headerlink" title="1.2.5 View Modifier"></a>1.2.5 View Modifier</h4><p><strong>View Modifier</strong> 是一种用于修改视图外观或行为的轻量方法。通过在视图后链式调用来设置属性和样式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">	 .imageScale(.large)</span><br><span class="line">	 .foregroundStyle(.tint)</span><br></pre></td></tr></table></figure>

<ul>
<li>在上述代码中，<code>.imageScale(.large)</code> 和 <code>.foregroundStyle(.tint)</code> 就是 <strong>View Modifier</strong></li>
<li>支持链式调用，可添加多个样式修改</li>
</ul>
<h4 id="1-2-6-View-Modifier-作用域"><a href="#1-2-6-View-Modifier-作用域" class="headerlink" title="1.2.6 View Modifier 作用域"></a>1.2.6 View Modifier 作用域</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Outer Text&quot;</span>)</span><br><span class="line">        .foregroundColor(.red)  <span class="comment">// 仅应用到此 Text</span></span><br><span class="line"></span><br><span class="line">    <span class="type">HStack</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Inner Text 1&quot;</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Inner Text 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .foregroundColor(.blue)  <span class="comment">// 应用于 HStack 内的所有子视图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用于容器视图的 Modifier 影响其所有子视图</strong>：上述代码中的 <code>.foregroundColor(.blue)</code> 应用于 <code>HStack</code> 的所有子视图 <code>Text</code>。</li>
<li><strong>并列层级的视图的 Modifier 互不影响</strong>：在此例中，<code>.foregroundColor(.blue)</code> 应用于 <code>HStack</code>，仅影响 <code>HStack</code> 中的 <code>Text</code> 视图，外层的 <code>Text(&quot;Outer Text&quot;)</code> 视图不受影响。</li>
</ul>
<h3 id="1-3-本节完整代码"><a href="#1-3-本节完整代码" class="headerlink" title="1.3 本节完整代码"></a>1.3 本节完整代码</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">CardView</span>(isFaceUp: <span class="literal">true</span>)</span><br><span class="line">            <span class="type">CardView</span>()</span><br><span class="line">            <span class="type">CardView</span>()</span><br><span class="line">            <span class="type">CardView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>(content: &#123;</span><br><span class="line">            <span class="keyword">if</span> isFaceUp &#123;</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">                    .foregroundColor(.white)</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">                    .strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;👻&quot;</span>).font(.largeTitle)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="type">Preview</span> &#123;</span><br><span class="line">    <span class="type">ContentView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-后续预习"><a href="#1-4-后续预习" class="headerlink" title="1.4 后续预习"></a>1.4 后续预习</h3><ul>
<li><strong>网格布局过渡</strong></li>
<li><strong>游戏逻辑的整合</strong></li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford cs193p 02 | More SwiftUI</title>
    <url>/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 02 集的相关笔记。</p>
<span id="more"></span>

<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>cs193p 课程网址: <a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></p>
<p>继续上一节记忆卡片的游戏制作，笔记按照课程项目制作步骤进行整理，在每个步骤依次对涉及的语法糖进行说明。建议在看第二节视频前预览一遍，了解教程框架，便于针对性的学习。</p>
<p>该笔记基于 <a href="https://nwdan.com/my-learning/stanford-cs193p-2.html">https://nwdan.com/my-learning/stanford-cs193p-2.html</a> 做了适当修改，添加了对于项目制作流程梳理，并在 <code>some View</code>、<code>@State</code>、<code>LazyVGrid</code> 等小节增加了部分说明。（ps：笔记非原创，原博主的笔记非常简洁清晰，推荐阅读。）</p>
<h2 id="1-创建一个-CardView-struct"><a href="#1-创建一个-CardView-struct" class="headerlink" title="1. 创建一个 CardView struct"></a>1. 创建一个 CardView struct</h2><h3 id="1-1-some-View"><a href="#1-1-some-View" class="headerlink" title="1.1 some View"></a>1.1 some View</h3><p>请看一段演示代码，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段演示代码同样可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">Text</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果我们放一些返回值不为 <code>Text</code> 的结构，编译器会报错 (Cannot convert return expression of type <code>&#39;VStack&lt;TupleView&lt;(Text, Text, Text)&gt;&gt;&#39;</code> to return type <code>&#39;Text&#39;</code>)：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">Text</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，如果我们放入多个 <code>Text</code> 的结构，编译器仍然会报错：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">Text</span> &#123;</span><br><span class="line">		<span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">		<span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>some View</code> 可以让编译器自动识别不同的返回类型。</p>
<h3 id="1-2-尾随闭包-Trailing-closure-syntax"><a href="#1-2-尾随闭包-Trailing-closure-syntax" class="headerlink" title="1.2 尾随闭包 (Trailing closure syntax)"></a>1.2 尾随闭包 (Trailing closure syntax)</h3><p>我们如果仔细看看 <code>VStack</code>, 我们传入了一个名为<code>content</code>的参数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>(alignment: .top, content: &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个函数的最后一个参数本身是一个函数，此时我们可以使用尾随闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>(alignment: .top) &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-RoundedRectangle"><a href="#1-3-RoundedRectangle" class="headerlink" title="1.3 RoundedRectangle"></a>1.3 RoundedRectangle</h3><p>当我们使用 RoundedRectangle 时，如果我们不指定具体的修改器，Swift 会默认填充。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line"><span class="comment">// These two codes are identical in terms of functionality.</span></span><br><span class="line"><span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>).fill()</span><br></pre></td></tr></table></figure>

<h3 id="1-4-局部变量-Local-Variable"><a href="#1-4-局部变量-Local-Variable" class="headerlink" title="1.4 局部变量 (Local Variable)"></a>1.4 局部变量 (Local Variable)</h3><p>我们可以创建一个局部变量:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isFaceUp &#123;</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>).fill(.white)</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>).strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;👻&quot;</span>).font(.largeTitle)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>).fill()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个局部变量名为 <code>base</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base: <span class="type">RoundedRectangle</span> <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            <span class="keyword">if</span> isFaceUp &#123;</span><br><span class="line">                base.fill(.white)</span><br><span class="line">                base.strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;👻&quot;</span>).font(.largeTitle)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                base.fill()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMPORTANT:</strong> 我们使用了关键字 <code>let</code> 而不是 <code>var</code>，因为这个变量一旦创建就不再能被改变。(<code>let</code> 通常用来创建常量)</p>
<h3 id="1-5-类型推断-Type-Inference"><a href="#1-5-类型推断-Type-Inference" class="headerlink" title="1.5 类型推断 (Type Inference)"></a>1.5 类型推断 (Type Inference)</h3><p>我们可以省略变量类型让 Swift 自动判定。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Without omit the type</span></span><br><span class="line"><span class="keyword">let</span> base: <span class="type">RoundedRectangle</span> <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line"><span class="comment">// Omited the type (using type inference)</span></span><br><span class="line"><span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以按住 <code>option</code> 键然后点击 <code>base</code> 变量，Swift 会显示自动判定的变量类型。</p>
<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_option.png"></p>
<blockquote>
<p>Note: 我们在生产环境几乎都使用类型推断，不手动指定变量类型。如果需要对返回的类型进行检查，则可指定变量类型。</p>
</blockquote>
<h3 id="1-6-onTapGesture"><a href="#1-6-onTapGesture" class="headerlink" title="1.6 .onTapGesture"></a>1.6 <code>.onTapGesture</code></h3><p>单击:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>尾随闭包</strong>：单击的方法为 <code>.onTapGesture(perform:&#123;&#125;)</code> ，此处由于最后一个参数本身是一个函数，所以使用尾随闭包 <code>.onTapGesture &#123; isFaceUp.toggle() &#125;</code></li>
</ul>
<p>双击:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture(count: <span class="number">2</span>) &#123;</span><br><span class="line">            isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-State"><a href="#1-7-State" class="headerlink" title="1.7 @State"></a>1.7 <code>@State</code></h3><p>这一段代码会报错 <code>Error: Cannot assign to property: &#39;self&#39; is immutable</code>。因为结构体的属性默认是不可变的。也就是说，在结构体的实例方法或闭包中不能直接修改它的属性，除非明确标记为 <code>mutating</code>。因此，当你在 struct 中使用一个属性（比如 isFaceUp），它默认是不可变的，在 .onTapGesture 中试图修改 isFaceUp 则会导致这个错误。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">        	isFaceUp <span class="operator">=</span> <span class="operator">!</span>isFaceUp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，一个变量在函数被调用后就不可改变。<code>@State</code> 关键字允许变量有临时的状态，因为 <code>@State</code> 会创建一个指针指向堆 (Heap) 中。因此，指针本身没有被改变，改变的是堆里存的数据。</p>
<p>在 <code>SwiftUI</code> 中， <code>@State</code> 属性包装器用来管理视图中的可变状态的，将 <code>isFaceUp</code> 声明为 <code>@State</code>，SwiftUI 会知道这个属性的变化会导致视图重新渲染。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>isFaceUp</code> 可以在视图中动态可变，且不会触发不可变性错误。</p>
<h2 id="2-生成一组-Card"><a href="#2-生成一组-Card" class="headerlink" title="2. 生成一组 Card"></a>2. 生成一组 Card</h2><h3 id="2-1-数组-Array"><a href="#2-1-数组-Array" class="headerlink" title="2.1 数组(Array)"></a>2.1 数组(Array)</h3><p>Swift 接受以下两种方式新建数组，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A valid array notation</span></span><br><span class="line"><span class="keyword">let</span> emojis: <span class="type">Array</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>]</span><br><span class="line"><span class="comment">// Alternate array notation</span></span><br><span class="line"><span class="keyword">let</span> emojis: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>我们也可以使用类型推论省略类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2-2-ForEach-循环"><a href="#2-2-ForEach-循环" class="headerlink" title="2.2 ForEach 循环"></a>2.2 ForEach 循环</h3><p><strong>ForEach 不包含最后一个数字</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterate from 0 to 3 (NOT including 4)</span></span><br><span class="line"><span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">4</span>, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">    <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note：<code>id:\.self</code> 会在 cs193p 后续课程中讲解</p>
</blockquote>
<p><strong>ForEach 包含最后一个数字</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterate from 0 to 4 (including 4)</span></span><br><span class="line"><span class="type">ForEach</span>(<span class="number">0</span><span class="operator">...</span><span class="number">4</span>, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">    <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ForEach （基于数组的长度）循环整个数组</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(emojis.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常在数组长度未知时使用该 <code>.indices</code> 方法。</p>
<h2 id="3-控制-Card-个数"><a href="#3-控制-Card-个数" class="headerlink" title="3. 控制 Card 个数"></a>3. 控制 Card 个数</h2><h3 id="3-1-按钮"><a href="#3-1-按钮" class="headerlink" title="3.1 按钮"></a>3.1 按钮</h3><h4 id="3-1-1-文本按钮"><a href="#3-1-1-文本按钮" class="headerlink" title="3.1.1 文本按钮"></a>3.1.1 文本按钮</h4><p>语法结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;Remove card&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// action</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>, <span class="string">&quot;💩&quot;</span>, <span class="string">&quot;🎉&quot;</span>, <span class="string">&quot;😎&quot;</span>]</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> cardCount <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                    <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;Remove card&quot;</span>) &#123;</span><br><span class="line">                    cardCount <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;Add card&quot;</span>) &#123;</span><br><span class="line">                    cardCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_textButton.png"></p>
<h4 id="3-1-2-图标按钮"><a href="#3-1-2-图标按钮" class="headerlink" title="3.1.2 图标按钮"></a>3.1.2 图标按钮</h4><p>语法结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(action: &#123;</span><br><span class="line">    <span class="comment">// action</span></span><br><span class="line">&#125;, label: &#123;</span><br><span class="line">    <span class="comment">// button icon, images, etc...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>, <span class="string">&quot;💩&quot;</span>, <span class="string">&quot;🎉&quot;</span>, <span class="string">&quot;😎&quot;</span>]</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> cardCount <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                    <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    cardCount <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">                &#125;, label: &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.minus.fill&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    cardCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                &#125;, label: &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            .imageScale(.large)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_iconButton.png"></p>
<h3 id="3-2-超出索引的问题"><a href="#3-2-超出索引的问题" class="headerlink" title="3.2 超出索引的问题"></a>3.2 超出索引的问题</h3><p>如果我们添加了太多的卡片，由于索引超出范围会导致程序崩溃。其中一种避免程序的方法是添加一个 <code>if</code> 逻辑。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(action: &#123;</span><br><span class="line">    <span class="keyword">if</span> cardCount <span class="operator">&lt;</span> emojis.count &#123;</span><br><span class="line">        cardCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, label: &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>另一种方法是使用 <code>.disabled</code> 视图修改器</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">cardCountAdjuster</span>(<span class="params">by</span> <span class="params">offset</span>: <span class="type">Int</span>, <span class="params">symbol</span>: <span class="type">String</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(action: &#123;</span><br><span class="line">        cardCount <span class="operator">+=</span> offset</span><br><span class="line">    &#125;, label: &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: symbol)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disabled(cardCount <span class="operator">+</span> offset <span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">||</span> cardCount <span class="operator">+</span> offset <span class="operator">&gt;</span> emojis.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 这节课的后半部分讲解了 Swift 中的函数。</p>
</blockquote>
<h2 id="4-整理代码"><a href="#4-整理代码" class="headerlink" title="4. 整理代码"></a>4. 整理代码</h2><h3 id="4-1-优化代码可读性"><a href="#4-1-优化代码可读性" class="headerlink" title="4.1 优化代码可读性"></a>4.1 优化代码可读性</h3><p>我们先看看 <code>body</code> 中包含的代码，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>, <span class="string">&quot;💩&quot;</span>, <span class="string">&quot;🎉&quot;</span>, <span class="string">&quot;😎&quot;</span>]</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> cardCount <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                    <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    <span class="keyword">if</span> cardCount <span class="operator">&gt;</span> <span class="number">1</span> &#123;</span><br><span class="line">                        cardCount <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, label: &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.minus.fill&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    <span class="keyword">if</span> cardCount <span class="operator">&lt;</span> emojis.count &#123;</span><br><span class="line">                        cardCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, label: &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            .imageScale(.large)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在看起来十分不整洁。我们可以创建其它视图提高代码的可读性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>, <span class="string">&quot;💩&quot;</span>, <span class="string">&quot;🎉&quot;</span>, <span class="string">&quot;😎&quot;</span>]</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> cardCount <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            cards</span><br><span class="line">            cardCountAdjusters</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cardCountAdjusters: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            cardRemover</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            cardAdder</span><br><span class="line">        &#125;</span><br><span class="line">        .imageScale(.large)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cardRemover: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">if</span> cardCount <span class="operator">&gt;</span> <span class="number">1</span> &#123;</span><br><span class="line">                cardCount <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, label: &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.minus.fill&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cardAdder: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">if</span> cardCount <span class="operator">&lt;</span> emojis.count &#123;</span><br><span class="line">                cardCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, label: &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在整理后，我们 <code>body</code> 中的代码现在看起来非常容易理解。</p>
<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_view.png"></p>
<h3 id="4-2-隐式返回值-Implicit-return"><a href="#4-2-隐式返回值-Implicit-return" class="headerlink" title="4.2 隐式返回值 (Implicit return)"></a>4.2 隐式返回值 (Implicit return)</h3><p>如果一个函数只有 1 行代码，我们就可以使用隐式返回。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">HStack</span> &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .foregroundColor(.orange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以使用 <code>return</code> 关键字显式返回。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">HStack</span> &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .foregroundColor(.orange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-函数-Function"><a href="#4-3-函数-Function" class="headerlink" title="4.3 函数 (Function)"></a>4.3 函数 (Function)</h3><p>语法结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">&lt;</span>function name<span class="operator">&gt;</span>(<span class="operator">&lt;</span>para name<span class="operator">&gt;</span>: <span class="operator">&lt;</span>data type<span class="operator">&gt;</span>) -&gt; <span class="operator">&lt;</span><span class="keyword">return</span> type<span class="operator">&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// function code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">cardCountAdjuster</span>(<span class="params">by</span> <span class="params">offset</span>: <span class="type">Int</span>, <span class="params">symbol</span>: <span class="type">String</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(action: &#123;</span><br><span class="line">        cardCount <span class="operator">+=</span> offset</span><br><span class="line">    &#125;, label: &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: symbol)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMPORTANT:</strong> <code>by offset: Int</code> 我们有时候会使用 2 个标签代表一个参数，第一个参数 <code>by</code> 在调用函数时使用，而第二个标签在函数内使用。第一个标签被称为 external parameter name，第二个标签被称为 internal parameter name。</p>
<p>现在我们的代码看起来更漂亮了,</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">cardCountAdjuster</span>(<span class="params">by</span> <span class="params">offset</span>: <span class="type">Int</span>, <span class="params">symbol</span>: <span class="type">String</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(action: &#123;</span><br><span class="line">        cardCount <span class="operator">+=</span> offset</span><br><span class="line">    &#125;, label: &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: symbol)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cardRemover: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cardCountAdjuster(by: <span class="operator">-</span><span class="number">1</span>, symbol: <span class="string">&quot;rectangle.stack.badge.minus.fill&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cardAdder: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cardCountAdjuster(by: <span class="number">1</span>, symbol: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 由于我们删除了 <code>if</code> 逻辑，我们程序可能由于数组超出索引范围而崩溃。但是我们在超出索引的问题章节讲了如何解决.</p>
</blockquote>
<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_function.png"></p>
<h2 id="5-优化布局"><a href="#5-优化布局" class="headerlink" title="5. 优化布局"></a>5. 优化布局</h2><h3 id="5-1-LazyVGrid"><a href="#5-1-LazyVGrid" class="headerlink" title="5.1 LazyVGrid"></a>5.1 LazyVGrid</h3><p>为了让这些卡片看起来比较正常，我们需要用<code>LazyVGrid</code>替代<code>HStack</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">120</span>))]) &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .foregroundColor(.orange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>LazyVGrid</code> 和 <code>LazyHGrid</code> 分别是垂直的网格布局、水平网格布局。<code>LazyVGrid</code> 通过制定列的数量然后来填充布局。<code>GridItem</code> 通过设置 Size 来控制格子的宽度：</p>
<ol>
<li><code>fixed</code> 通过指定固定大小来确定格子宽度</li>
<li><code>flexible </code> 弹性大小，会和其他 flexible 的格子分割剩余的空间，可以设置期望的最大和最小值。如果指定的最小值过大可能会超出屏幕</li>
<li><code>adaptive</code> 自适应分布, 这个尺寸会提供一个或者多个格子。需要指定一个最小值, 也可以设置最大值，然后根据最小值在把自身占用的区域平分成若干个满足最小值最大值的的格子。可以理解 adaptive 为一个 flexible 大格子，获得空间后再把这个大格子平分成若干个满足设置定值的小格子。</li>
</ol>
</blockquote>
<p>我们需要在<code>cards</code> 和 <code>cardCountAdjusters</code>之间添加一个<code>Spacer()</code>，这样它们不会挤到一起去。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        cards</span><br><span class="line">        <span class="type">Spacer</span>()</span><br><span class="line">        cardCountAdjusters</span><br><span class="line">    &#125;</span><br><span class="line">    .padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>LazyVGrid</code>会使用尽可能少的空间，因此，当两张卡片都为背面时会被挤压到一起去。</p>
<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_lazyVGrid.png"></p>
<h3 id="5-2-opacity"><a href="#5-2-opacity" class="headerlink" title="5.2 .opacity"></a>5.2 <code>.opacity</code></h3><p>我们需要修改<code>CardView</code>的逻辑</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> content: <span class="type">String</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                base.foregroundColor(.white)</span><br><span class="line">                base.strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(content).font(.largeTitle)</span><br><span class="line">            &#125;</span><br><span class="line">            .opacity(isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            base.fill().opacity(isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题解决！</p>
<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_opacity.png"></p>
<h3 id="5-3-aspectRatio"><a href="#5-3-aspectRatio" class="headerlink" title="5.3 .aspectRatio"></a>5.3 <code>.aspectRatio</code></h3><p>使用 <code>aspectRatio</code> 控制视图的宽高比</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">120</span>))]) &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">                .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .foregroundColor(.orange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_aspectRatio.png"></p>
<h3 id="5-4-ScrollView"><a href="#5-4-ScrollView" class="headerlink" title="5.4 ScrollView"></a>5.4 ScrollView</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">ScrollView</span> &#123;</span><br><span class="line">            cards</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Spacer</span>()</span><br><span class="line">        cardCountAdjusters</span><br><span class="line">    &#125;</span><br><span class="line">    .padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford cs193p 03｜MVVM</title>
    <url>/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 03 集的相关笔记。</p>
<span id="more"></span>

<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>本节前言：</p>
<blockquote>
<p>Conceptual overview of the architectural paradigm underlying the development of applications for iOS using SwiftUI (known as MVVM). Explanation of a fundamental component of understanding the Swift programming language: its type system. Start to apply both of these to Memorize.</p>
</blockquote>
<p>cs193p 课程网址: <a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></p>
<p>推荐的拓展练习教程：todolist MVVM（约 130 分钟） <a href="https://ur0.jp/jVOQG">https://ur0.jp/jVOQG</a></p>
<hr>
<h2 id="0-本节框架"><a href="#0-本节框架" class="headerlink" title="0. 本节框架"></a>0. 本节框架</h2><ul>
<li><p>MVVM</p>
<p>MVVM 架构简介与特点</p>
</li>
<li><p><code>swift</code> 类型</p>
<ul>
<li><code>struct</code> vs <code>class</code></li>
<li><code>protocol</code></li>
<li>“don’t care” type (aka <code>generics</code>)</li>
<li><code>enum</code>（略，但很重要）</li>
<li><code>functions</code></li>
</ul>
</li>
<li><p>Demo<br>续上节记忆游戏，因 demo 太短，将 demo 合并到了下一篇笔记中。</p>
</li>
</ul>
<h2 id="1-Model-and-UI"><a href="#1-Model-and-UI" class="headerlink" title="1. Model and UI"></a>1. Model and UI</h2><h3 id="1-1-将“逻辑与数据”与“用户界面”分离"><a href="#1-1-将“逻辑与数据”与“用户界面”分离" class="headerlink" title="1.1 将“逻辑与数据”与“用户界面”分离"></a>1.1 将“逻辑与数据”与“用户界面”分离</h3><ul>
<li>SwiftUI 强调将应用程序逻辑和数据与用户界面分离。我们将这些逻辑和数据称为 <strong>模型（Model）</strong>。</li>
<li>模型可以是 <code>struct</code>、<code>SQL</code> 数据库、机器学习代码或其他多种形式的组合。</li>
<li>用户界面基本上只是一个“可参数化”的外壳，由模型提供数据并赋予其生命。</li>
<li><strong>用户界面是模型的可视化表现</strong>。</li>
<li>模型是存放像 <code>isFaceUp</code> 和 <code>cardCount</code> 这样的状态的地方，而这些状态不应该放在 UI 的 <code>@State</code> 中。</li>
<li>SwiftUI 会确保当模型变化影响到用户界面时，用户界面会被重新构建。</li>
</ul>
<h3 id="1-2-将模型连接到用户界面"><a href="#1-2-将模型连接到用户界面" class="headerlink" title="1.2 将模型连接到用户界面"></a>1.2 将模型连接到用户界面</h3><p>在将模型与用户界面连接时，有几种选择：</p>
<ol>
<li><strong>几乎不分离</strong>：极少数情况下，模型可以作为视图中的 <code>@State</code></li>
<li><strong>完全分离</strong>：模型可能仅能通过一个充当“门卫”的 <strong>视图模型（View Model）</strong> <code>class</code> 进行访问</li>
<li><strong>部分分离</strong>：存在一个视图模型 <code>class</code>，但模型仍然可以直接访问</li>
</ol>
<p>这三种选择主要取决于模型的复杂性：</p>
<ul>
<li>一个由 SQL + <code>struct</code> + 其他元素组成的模型，可能会选择第二种方案</li>
<li>如果模型只是一小段简单数据且涉及的逻辑很少，可能会选择第一种方案</li>
<li>介于两者之间的情况可能会考虑第三种方案</li>
</ul>
<p>本节将重点讨论第二种方案（完全分离）。我们将这种连接模型与用户界面的架构称为 <strong>MVVM</strong> （模型-视图-视图模型）。</p>
<ul>
<li><strong>MVVM</strong> 是相对复杂的 SwiftUI 应用的主要架构</li>
<li>第三种方案（部分分离）是对 MVVM 的细微调整</li>
</ul>
<h2 id="2-MVVM"><a href="#2-MVVM" class="headerlink" title="2. MVVM"></a>2. MVVM</h2><h3 id="2-1-MVVM-简介"><a href="#2-1-MVVM-简介" class="headerlink" title="2.1 MVVM 简介"></a>2.1 MVVM 简介</h3><p><strong>MVVM (Model-View-ViewModel)</strong> 是一种架构模式，将视图（UI）和业务逻辑分离，从而提高代码可读性、可维护性和复用性。它将代码分为三个部分：</p>
<ul>
<li><strong>Model（模型层）：</strong> 负责管理数据和业务逻辑。通常是数据模型，可能包含从服务器或本地数据库获取的内容。</li>
<li><strong>View（视图层）：</strong> 负责展示 UI，声明式地描述界面如何响应数据变化。视图只与 ViewModel 交互，而不直接操作 Model。</li>
<li><strong>ViewModel（视图模型层）：</strong> 负责连接 View 和 Model。ViewModel 通过处理数据和业务逻辑，将数据转换为视图需要的形式，并通过绑定的方式通知视图更新。</li>
</ul>
<h3 id="2-2-MVVM-特点"><a href="#2-2-MVVM-特点" class="headerlink" title="2.2 MVVM 特点"></a>2.2 MVVM 特点</h3><ul>
<li>解耦：View 和 Model 相互独立，ViewModel 承担数据转换任务，减少 UI 和业务逻辑的耦合。</li>
<li>数据驱动：ViewModel 中的属性通常是可观察的（例如 SwiftUI 中的 @Published 属性），使得数据变化时自动触发 UI 更新。</li>
<li>单向数据流：Model 更新时，通知 ViewModel，进而通知 View；用户操作从 View 传递到 ViewModel 进行处理。</li>
</ul>
<p><img src="/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/cs193p03_MVVM.png"></p>
<h3 id="2-3-数据流在-MVVM-中的运作"><a href="#2-3-数据流在-MVVM-中的运作" class="headerlink" title="2.3 数据流在 MVVM 中的运作"></a>2.3 数据流在 MVVM 中的运作</h3><ul>
<li><p><strong>从 Model 到 View</strong></p>
<ol>
<li>ViewModel 从 Model 获取数据（如从网络或本地加载）。</li>
<li>ViewModel 通过 @Published 属性将数据暴露给视图。</li>
<li>视图观察 ViewModel，当数据更新时，自动重新渲染。</li>
</ol>
</li>
<li><p><strong>从 View 到 Model</strong></p>
<ol>
<li>用户在视图中进行交互</li>
<li>交互事件触发 ViewModel 的方法</li>
<li>ViewModel 修改 Model 或处理业务逻辑，更新数据后通知视图。</li>
</ol>
</li>
</ul>
<h3 id="2-4-补充举例（非视频内容）"><a href="#2-4-补充举例（非视频内容）" class="headerlink" title="2.4 补充举例（非视频内容）"></a>2.4 补充举例（非视频内容）</h3><p>以下是一个示例，展示如何在 SwiftUI 中实现 MVVM 架构。</p>
<blockquote>
<p>这一部分是为了辅助理解 MVVM 架构，不用实现。</p>
</blockquote>
<h4 id="2-4-1-模型层（Model）"><a href="#2-4-1-模型层（Model）" class="headerlink" title="2.4.1 模型层（Model）"></a>2.4.1 模型层（Model）</h4><p>模型负责表示应用的数据结构。通常是简单的数据类型，可能从服务器或本地数据库加载。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Habit</span>: <span class="title class_ inherited__">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> isCompleted: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-视图模型层（ViewModel）"><a href="#2-4-2-视图模型层（ViewModel）" class="headerlink" title="2.4.2 视图模型层（ViewModel）"></a>2.4.2 视图模型层（ViewModel）</h4><p><code>ViewModel</code> 负责管理业务逻辑和状态，并通过数据绑定将数据暴露给视图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HabitViewModel</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="comment">// 可观察的属性，视图会自动更新</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> habits: [<span class="type">Habit</span>] <span class="operator">=</span> [</span><br><span class="line">        <span class="type">Habit</span>(id: <span class="number">1</span>, name: <span class="string">&quot;Exercise&quot;</span>, isCompleted: <span class="literal">false</span>),</span><br><span class="line">        <span class="type">Habit</span>(id: <span class="number">2</span>, name: <span class="string">&quot;Read a Book&quot;</span>, isCompleted: <span class="literal">true</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新习惯完成状态</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">toggleHabitCompletion</span>(<span class="keyword">_</span> <span class="params">habit</span>: <span class="type">Habit</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index <span class="operator">=</span> habits.firstIndex(where: &#123; <span class="variable">$0</span>.id <span class="operator">==</span> habit.id &#125;) &#123;</span><br><span class="line">            habits[index].isCompleted.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Published</code>：使得 <code>habits</code> 的变化可以被 SwiftUI 的 <code>View</code> 观察到，从而触发 UI 更新。</li>
<li><strong>方法</strong>：封装了业务逻辑，例如切换习惯完成状态。</li>
</ul>
<h4 id="2-4-3-视图层（View）"><a href="#2-4-3-视图层（View）" class="headerlink" title="2.4.3 视图层（View）"></a>2.4.3 视图层（View）</h4><p>视图是完全声明式的，只关注 UI 和数据的绑定，不直接操作 <code>Model</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HabitListView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> viewModel <span class="operator">=</span> <span class="type">HabitViewModel</span>() <span class="comment">// 创建 ViewModel 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">List</span>(viewModel.habits) &#123; habit <span class="keyword">in</span></span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(habit.name)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Button</span>(action: &#123;</span><br><span class="line">                        viewModel.toggleHabitCompletion(habit) <span class="comment">// 用户操作通知 ViewModel</span></span><br><span class="line">                    &#125;) &#123;</span><br><span class="line">                        <span class="type">Image</span>(systemName: habit.isCompleted <span class="operator">?</span> <span class="string">&quot;checkmark.circle.fill&quot;</span> : <span class="string">&quot;circle&quot;</span>)</span><br><span class="line">                            .foregroundColor(habit.isCompleted <span class="operator">?</span> .green : .gray)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;My Habits&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@StateObject</code>：用于初始化 <code>ViewModel</code>，使视图能够观察其状态变化。</li>
<li><strong>数据绑定</strong>：<code>viewModel.habits</code> 与列表内容绑定，<code>@Published</code> 属性变化时自动更新视图。</li>
<li><strong>用户操作</strong>：通过按钮操作调用 <code>ViewModel</code> 方法，而不直接操作 <code>Model</code>。</li>
</ul>
<h2 id="3-Varieties-of-Types"><a href="#3-Varieties-of-Types" class="headerlink" title="3. Varieties of Types"></a>3. Varieties of Types</h2><h3 id="3-1-struct-and-class"><a href="#3-1-struct-and-class" class="headerlink" title="3.1 struct and class"></a>3.1 struct and class</h3><h4 id="3-1-1-struct-class-共同点"><a href="#3-1-1-struct-class-共同点" class="headerlink" title="3.1.1 struct &amp; class 共同点"></a>3.1.1 struct &amp; class 共同点</h4><p>在 Swift 中，<code>struct</code> 和 <code>class</code> 具有以下特征：</p>
<ul>
<li><p><strong>语法相似</strong>：它们的语法几乎完全相同。</p>
</li>
<li><p><strong>存储属性</strong>（stored vars）：类似于你熟悉的那种存储在内存中的属性，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isFaceUp: <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>计算属性</strong>（computed vars）：其值是通过评估一些代码得出的属性，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常量</strong>（constant lets）：其值不会改变的属性，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColor <span class="operator">=</span> <span class="type">Color</span>.orange</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="type">CardView</span>().foregroundColor(defaultColor)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数</strong>（functions）：可以定义行为，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">multiply</span>(<span class="params">operand</span>: <span class="type">Int</span>, <span class="params">by</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> operand <span class="operator">*</span> by</span><br><span class="line">&#125;</span><br><span class="line">multiply(operand: <span class="number">5</span>, by: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">multiply</span>(<span class="keyword">_</span> <span class="params">operand</span>: <span class="type">Int</span>, <span class="params">by</span> <span class="params">otherOperand</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> operand <span class="operator">*</span> otherOperand</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">5</span>, by: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化器</strong>（initializers）：在创建 <code>struct</code> 或 <code>class</code> 时调用的特殊函数，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RoundedRectangle</span> &#123;</span><br><span class="line">	<span class="keyword">init</span>(<span class="params">cornerRadius</span>: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 cornerRadius 初始化矩形</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">init</span>(<span class="params">cornerSize</span>: <span class="type">CGSize</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 cornerSize 初始化矩形</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-1-2-struct-vs-class-区别"><a href="#3-1-2-struct-vs-class-区别" class="headerlink" title="3.1.2 struct vs class 区别"></a>3.1.2 struct vs class 区别</h4><table>
<thead>
<tr>
<th>struct</th>
<th>class</th>
</tr>
</thead>
<tbody><tr>
<td>值类型</td>
<td>引用类型</td>
</tr>
<tr>
<td>传递或赋值时会被复制</td>
<td>通过指针传递</td>
</tr>
<tr>
<td>复制时写入（只有在被修改时才真正复制）</td>
<td>自动引用计数</td>
</tr>
<tr>
<td>函数式编程</td>
<td>面向对象编程</td>
</tr>
<tr>
<td>不支持继承</td>
<td>支持单继承</td>
</tr>
<tr>
<td>“免费的” <strong>init</strong>初始化所有的 <strong>var</strong></td>
<td>“免费的” <strong>init</strong> 不初始化任何 <strong>var</strong></td>
</tr>
<tr>
<td>可变性是显式的（<strong>var</strong> 与 <strong>let</strong> 的区分）</td>
<td>始终可变</td>
</tr>
<tr>
<td>常用的数据结构</td>
<td>在特定情况下使用</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>值类型 vs 引用类型</strong>：<code>struct</code> 是值类型，这意味着当它们被传递或赋值时，会创建一个全新的副本；而 <code>class</code> 是引用类型，传递或赋值时只是将引用指向同一实例。</p>
</li>
<li><p><strong>复制时写入</strong>：对于 <code>struct</code>，只有在它们被修改时，才会生成新的副本（写时复制），这通常用于优化内存使用。</p>
</li>
<li><p><strong>自动引用计数</strong>：<code>class</code> 的实例会被 Swift 的内存管理系统自动引用计数，这意味着当没有强引用指向某个实例时，它会被自动释放。</p>
</li>
<li><p><strong>函数式编程 vs 面向对象编程</strong>：<code>struct</code> 常用于函数式编程范式，而 <code>class</code> 则广泛用于面向对象编程，后者强调对象的封装和继承。</p>
</li>
<li><p><strong>继承</strong>：<code>struct</code> 不支持继承，因此它不能从其它结构体派生；而 <code>class</code> 支持单层继承，允许子类从父类继承属性和方法。</p>
</li>
<li><p><strong>初始化器</strong>：对于 <code>struct</code>，默认情况下，Swift 会生成一个初始化器，确保所有属性都有默认值；而 <code>class</code> 的默认初始化器不会初始化任何属性，除非你自己定义。</p>
</li>
<li><p><strong>可变性</strong>：在使用 <code>struct</code> 时，变量（<code>var</code>）和常量（<code>let</code>）的定义影响其可变性，因此你需要显式声明；而 <code>class</code> 实例的属性默认是可变的，不论是用 <code>var</code> 还是 <code>let</code>。</p>
</li>
<li><p><strong>使用场景</strong>：在开发中，<code>struct</code> 通常是更常用的选择，这是因为它们提供了更好的内存管理和性能，特别是在需要值传递的场景；而 <code>class</code> 则适合需要共享状态或需要继承的情况。</p>
</li>
</ul>
<blockquote>
<p>截止目前课程所看到的都是 <code>struct</code>，MVVM 架构中的 ViewModel 是 <code>class</code>。</p>
</blockquote>
<h3 id="3-2-Generics-泛型"><a href="#3-2-Generics-泛型" class="headerlink" title="3.2 Generics 泛型"></a>3.2 Generics 泛型</h3><ul>
<li>有时我们不关心具体类型，想操作类型无关的数据结构。</li>
<li>Swift 是强类型语言，所以我们不能使用无类型的变量。解决办法是使用“泛型”。</li>
</ul>
<h4 id="3-2-1-Generics-示例：Array"><a href="#3-2-1-Generics-示例：Array" class="headerlink" title="3.2.1 Generics 示例：Array"></a>3.2.1 Generics 示例：<code>Array</code></h4><ul>
<li><p><code>Array</code> 可以包含多种类型的元素而不关心具体类型。</p>
</li>
<li><p><code>Array</code> 的声明如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>append</code> 的参数是 <code>Element</code>，表示一种“无所谓”类型。</p>
</li>
<li><p>使用 <code>Array</code> 时，我们可以指定具体类型，如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时 Element 为 Int 类型</span></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">a.append(<span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时 Element 为 String 类型</span></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">a.append(<span class="string">&quot;🌼&quot;</span>)</span><br><span class="line">a.append(<span class="string">&quot;🍉&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Element</code> 的类型在使用 <code>Array</code> 时确定。</p>
</li>
<li><p>泛型允许同时使用多个类型参数（如 <code>&lt;Element, Foo&gt;</code>）。</p>
</li>
<li><p>“无所谓”类型称为 <strong>类型参数</strong>。</p>
</li>
</ul>
<p>总之，泛型能让我们在不知道具体类型的情况下灵活操作数据结构。</p>
<h3 id="3-3-protocol-协议"><a href="#3-3-protocol-协议" class="headerlink" title="3.3 protocol 协议"></a>3.3 protocol 协议</h3><h4 id="3-3-1-protocol-协议的特点"><a href="#3-3-1-protocol-协议的特点" class="headerlink" title="3.3.1 protocol 协议的特点"></a>3.3.1 protocol 协议的特点</h4><h5 id="1-protocol-有函数和方法，但不能具体实现或存储"><a href="#1-protocol-有函数和方法，但不能具体实现或存储" class="headerlink" title="1. protocol 有函数和方法，但不能具体实现或存储"></a><strong>1. protocol 有函数和方法，但不能具体实现或存储</strong></h5><p>声明一个协议的语法与 struct 或 class 很相似，只是没有具体实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protocol</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">move</span>(<span class="params">by</span>: <span class="type">Int</span>)</span><br><span class="line"><span class="keyword">var</span> hasMoved: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> distanceFromStart: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>&#123; &#125;</code> 中的内容用于说明该协议的变量是只读（get）还是可读写（get set）。</p>
<p><strong>举例说明</strong></p>
<p>任意类型都可以实现 Moveable 协议，只需要在 struct 内部实现 <code>move(by)</code> 、<code>hasMoved</code> 和 <code>distanceFromStart</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PortableThing</span>: <span class="title class_ inherited__">Moveable</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里必须实现 move(by:)、hasMoved 和 distanceFromStart</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 <code>PortableThing</code> 结构体便符合 <code>Moveable</code> 协议。</p>
<h5 id="2-protocol-协议可以继承其他-protocol"><a href="#2-protocol-协议可以继承其他-protocol" class="headerlink" title="2. protocol 协议可以继承其他 protocol"></a>2. <strong>protocol</strong> 协议可以继承其他 protocol</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Vehicle</span>: <span class="title class_ inherited__">Moveable</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> passengerCount: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里必须实现 move(by:)、hasMoved、distanceFromStart 和 passengerCount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-一个类可以同时实现多个协议"><a href="#3-一个类可以同时实现多个协议" class="headerlink" title="3. 一个类可以同时实现多个协议"></a>3. 一个类可以同时实现多个协议</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_ inherited__">Vehicle</span>, <span class="title class_ inherited__">Impoundable</span>, <span class="title class_ inherited__">Leasable</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里必须实现所有协议中的函数和变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-protocol-协议的用途"><a href="#3-3-2-protocol-协议的用途" class="headerlink" title="3.3.2 protocol 协议的用途"></a>3.3.2 protocol 协议的用途</h4><ol>
<li><p><strong>统一行为定义</strong></p>
<p>协议可以用于定义一组类型的共同行为，而无需关心这些类型的具体实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">fly</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bird</span>: <span class="title class_ inherited__">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">fly</span>() &#123;</span><br><span class="line">	  <span class="built_in">print</span>(<span class="string">&quot;Bird is flying!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Airplane</span>: <span class="title class_ inherited__">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">fly</span>() &#123;</span><br><span class="line">	  <span class="built_in">print</span>(<span class="string">&quot;Airplane is flying!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flyer: [<span class="type">Flyable</span>] <span class="operator">=</span> [<span class="type">Bird</span>(), <span class="type">Airplane</span>()]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> flyer &#123;</span><br><span class="line">  item.fly()  <span class="comment">// 不同类型的对象都可以飞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Flyable 定义了所有可飞行的类型应具备的行为。</li>
<li>通过协议，可以统一处理 Bird 和 Airplane 等符合协议的类型。</li>
</ul>
<p>另外，比如，<code>struct ContentView: View</code>  使得  <code>ContentView</code>  成为一个强大的结构体，虽然需要实现  <code>var body</code>  来满足  <code>View</code>  协议。</p>
</li>
<li><p><strong>协议与泛型</strong></p>
<p>协议可以与泛型结合，约束泛型参数必须符合某些协议，从而提升代码的类型安全性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printDetails</span>&lt;<span class="type">T</span>: <span class="type">CustomStringConvertible</span>&gt;(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">T</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(item.description)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printDetails(<span class="number">42</span>)            <span class="comment">// 输出：42</span></span><br><span class="line">printDetails(<span class="string">&quot;Swift Rocks&quot;</span>) <span class="comment">// 输出：Swift Rocks</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>泛型参数 T 必须符合 CustomStringConvertible 协议。</li>
<li>这种约束确保函数可以使用 description 属性，而不会导致运行时错误。</li>
</ul>
<h4 id="3-3-3-常见协议示例"><a href="#3-3-3-常见协议示例" class="headerlink" title="3.3.3 常见协议示例"></a>3.3.3 常见协议示例</h4><p>常见协议包括：</p>
<ul>
<li><strong>Identifiable</strong></li>
<li><strong>Hashable</strong></li>
<li><strong>Equatable</strong></li>
<li><strong>CustomStringConvertible</strong></li>
<li>特定的协议如 <strong>Animatable</strong>。</li>
</ul>
<h4 id="3-3-4-协议的优点"><a href="#3-3-4-协议的优点" class="headerlink" title="3.3.4 协议的优点"></a>3.3.4 协议的优点</h4><ol>
<li><strong>定义行为的蓝图</strong>：用于统一定义一组行为（方法、属性）。</li>
<li><strong>实现多态性</strong>：使不同类型可以通过统一接口交互。</li>
<li><strong>泛型约束</strong>：提升代码的类型安全性和复用性。</li>
<li><strong>协议扩展</strong>：减少重复代码，为协议提供默认实现。</li>
<li><strong>灵活组合</strong>：通过协议组合构建更强大的接口。</li>
</ol>
<h3 id="3-4-enum"><a href="#3-4-enum" class="headerlink" title="3.4 enum"></a>3.4 <code>enum</code></h3><blockquote>
<p>本节略过，但很重要。</p>
</blockquote>
<h3 id="3-5-Functions"><a href="#3-5-Functions" class="headerlink" title="3.5 Functions"></a>3.5 Functions</h3><p>函数类型可以像其他类型一样使用，由参数类型列表和返回类型组成。语法为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(参数类型列表) -&gt; 返回类型</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">square</span>(<span class="params">operand</span>: <span class="type">Double</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> operand <span class="operator">*</span> operand</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> operation <span class="operator">=</span> square <span class="comment">// just assigning a value to the operation vars, nothing more</span></span><br><span class="line"><span class="keyword">let</span> result1 <span class="operator">=</span> operation(<span class="number">4</span>) <span class="comment">// result1 would equal 16</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>square</code> 函数的类型：<code>(Double) -&gt; Double</code>，表示接收一个 <code>Double</code> 参数并返回一个 <code>Doubel</code> 值。</li>
<li><code>operation</code> 是一个变量：存储了函数 <code>square</code>，可以通过变量调用。</li>
</ul>
<p><strong>函数类型示例</strong>：</p>
<ul>
<li><code>(Int, Int) -&gt; Bool</code>：接受两个 Int 类型参数，返回一个 Bool 值。</li>
<li><code>(Double) -&gt; Void</code>：接受一个 Double 类型参数，无返回值。</li>
<li><code>() -&gt; Array&lt;String&gt;</code>：不接受参数，返回一个 String 数组。</li>
<li><code>() -&gt; Void</code>：不接受参数，无返回值（这是一个常见的用法）。</li>
</ul>
<p>在 Swift 中，函数类型可以像其他类型一样使用，可以存储函数并通过变量调用。</p>
<h4 id="3-5-1-闭包类型（Function-as-type）"><a href="#3-5-1-闭包类型（Function-as-type）" class="headerlink" title="3.5.1 闭包类型（Function as type）"></a>3.5.1 闭包类型（Function as type）</h4><p>函数类型也适用于闭包。闭包是未命名的函数，它的语法更加简洁。你可以将闭包存储在变量中，或直接作为函数的参数，通常被称为“内联函数”。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="operator">=</span> &#123; (a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(operation(<span class="number">4</span>, <span class="number">6</span>))  <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure>

<p>在 Swift 中，许多 SwiftUI 的功能（如@ViewBuilders 和 onTapGesture 的动作）都是通过闭包实现的。</p>
<h2 id="4-Demo"><a href="#4-Demo" class="headerlink" title="4. Demo"></a>4. Demo</h2><p>由于 demo 太短（大约只有 15 分钟），将这节课的 demo 合并到下一篇笔记中。</p>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford cs193p 04｜MVVM 应用</title>
    <url>/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 04 集的相关笔记。</p>
<span id="more"></span>

<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>cs193p 课程网址: <a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></p>
<p>为便于梳理，本节笔记包含了第三节课最后 15 分钟、第四节课以及第五节课前四分钟的内容。</p>
<hr>
<h2 id="1-第三节课最后-15-分钟"><a href="#1-第三节课最后-15-分钟" class="headerlink" title="1. 第三节课最后 15 分钟"></a>1. 第三节课最后 15 分钟</h2><h3 id="1-1-整理代码"><a href="#1-1-整理代码" class="headerlink" title="1.1 整理代码"></a>1.1 整理代码</h3><p>我们在应用 MVVM 设计思想前需要清理一下代码。</p>
<p>移除以下部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> cardCount: <span class="type">Int</span> <span class="operator">=</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cardCountAdjsters: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">HStack</span> &#123;</span><br><span class="line">        cardRemover</span><br><span class="line">        <span class="type">Spacer</span>()</span><br><span class="line">        cardAdder</span><br><span class="line">    &#125;</span><br><span class="line">    .imageScale(.large)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">cardCountAdjsters</span>(<span class="params">by</span> <span class="params">offset</span>: <span class="type">Int</span>, <span class="params">symbol</span>: <span class="type">String</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(action: &#123;</span><br><span class="line">        cardCount <span class="operator">+=</span> offset</span><br><span class="line">    &#125;, label: &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: symbol)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disabled(cardCount <span class="operator">+</span> offset <span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">||</span> cardCount <span class="operator">+</span> offset <span class="operator">&gt;</span> emojis.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cardRemover: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cardCountAdjsters(by: <span class="operator">-</span><span class="number">1</span>, symbol: <span class="string">&quot;rectangle.stack.badge.minus.fill&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cardAdder: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cardCountAdjsters(by: <span class="number">1</span>, symbol: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改成以下部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">...</span></span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">ScrollView</span> &#123;</span><br><span class="line">                cards</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            cardCountAdjsters</span><br><span class="line">        &#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="comment">// change to</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">        <span class="type">ScrollView</span> &#123;</span><br><span class="line">            cards</span><br><span class="line">        &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">            <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line"><span class="comment">// change to</span></span><br><span class="line">            <span class="type">ForEach</span>(emojis.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-新建一个-Model-文件"><a href="#1-2-新建一个-Model-文件" class="headerlink" title="1.2 新建一个 Model 文件"></a>1.2 新建一个 Model 文件</h3><p><code>File</code> -&gt; <code>New</code> -&gt; <code>File</code> -&gt; <code>Swift File</code>, 并将文件命名为 MemorizeGame</p>
<p><img src="/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/cs193p04_newFile.png"></p>
<p><strong>实现（写）一个 MemorizeGame (Model):</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span></span><br><span class="line">        <span class="keyword">var</span> isMatched: <span class="type">Bool</span></span><br><span class="line">        <span class="keyword">var</span> content: <span class="type">CardContent</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-新建一个-ViewModel-文件"><a href="#1-3-新建一个-ViewModel-文件" class="headerlink" title="1.3 新建一个 ViewModel 文件"></a>1.3 新建一个 ViewModel 文件</h3><p><code>File</code> -&gt; <code>New</code> -&gt; <code>File</code> -&gt; <code>Swift File</code>, then named as EmojiMemoryGame</p>
<p><strong>实现（写）一个 MemorizeGame (ViewModel):</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> model: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-第四节课"><a href="#2-第四节课" class="headerlink" title="2. 第四节课"></a>2. 第四节课</h2><h3 id="2-1-访问控制：实现由部分分离转为全部分离"><a href="#2-1-访问控制：实现由部分分离转为全部分离" class="headerlink" title="2.1 访问控制：实现由部分分离转为全部分离"></a>2.1 访问控制：实现由部分分离转为全部分离</h3><h4 id="2-1-1-部分分离"><a href="#2-1-1-部分分离" class="headerlink" title="2.1.1 部分分离"></a>2.1.1 部分分离</h4><p>我们来看看 MVVM 文件:</p>
<p><strong>View:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> viewModel: <span class="type">EmojiMemoryGame</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>]</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Model:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ViewModel:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> model: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们现在仍然可以在 <code>View</code> 中通过 <code>viewModel.model.xxx</code> 直接从 View 访问 Model，因此这是部分分离模式。</p>
<h4 id="2-1-2-完全分离"><a href="#2-1-2-完全分离" class="headerlink" title="2.1.2 完全分离"></a>2.1.2 完全分离</h4><p>如果我们想避免 View 直接访问 Model，我们需要使用关键字 <code>private</code> 来实现。这被称为完全分离。</p>
<p>修改 <strong>ViewModel</strong>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们现在如何访问 model 呢？我们需要修改 ViewModel 让它可以被访问。</p>
<p>这是修改过后的 <strong>ViewModel</strong>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">	<span class="comment">// private 使得 View 无法直接访问 model；这里意味着在 ViewModel 中使用 Model</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 ViewModel 中访问 model 中的数据 cards</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> model.cards</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 ViewModel 中实现对 model 中的 card 的 choose 操作</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="params">card</span>: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>) &#123;</span><br><span class="line">        model.choose(card: card)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="private-set"><a href="#private-set" class="headerlink" title="private(set)"></a>private(set)</h5><p>对应的在 <code>Model</code> 中应该怎么修改呢？</p>
<p><code>private(set)</code> 关键字允许其他函数只能读，但不可以修改。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryGame.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-ViewModel-方法补充和-Model-对应修改"><a href="#2-2-ViewModel-方法补充和-Model-对应修改" class="headerlink" title="2.2 ViewModel 方法补充和 Model 对应修改"></a>2.2 ViewModel 方法补充和 Model 对应修改</h3><h4 id="2-2-1-Model-的-choose-函数声明和-ViewModel-的-choose-函数声明调用"><a href="#2-2-1-Model-的-choose-函数声明和-ViewModel-的-choose-函数声明调用" class="headerlink" title="2.2.1 Model 的 choose 函数声明和 ViewModel 的 choose 函数声明调用"></a>2.2.1 <code>Model</code> 的 choose 函数声明和 <code>ViewModel</code> 的 choose 函数声明调用</h4><h5 id="忽略函数标签-No-External-Name"><a href="#忽略函数标签-No-External-Name" class="headerlink" title="忽略函数标签 (No External Name)"></a>忽略函数标签 (No External Name)</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryGame.swift</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>) &#123;</span><br><span class="line">        model.choose(card)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>choose</code>函数在被外部调用后不需要有外部称呼。然而，我们在一些情况下不需要省略外部称呼：</p>
<ol>
<li>数据类型是字符串，整数，或不确定的。</li>
<li>添加外部称呼可以增加代码的可读性。</li>
</ol>
<h4 id="2-2-2-Model-结构体的初始化器和-ViewModel-类初始化"><a href="#2-2-2-Model-结构体的初始化器和-ViewModel-类初始化" class="headerlink" title="2.2.2 Model 结构体的初始化器和 ViewModel 类初始化"></a>2.2.2 <code>Model</code> 结构体的初始化器和 <code>ViewModel</code> 类初始化</h4><p>类初始值设定项没有参数，并且仅当所有变量都有默认值时才起作用。 我们接下来开始写 <strong>ViewModel</strong> (EmojiMemoryGame.swift) 初始化函数。</p>
<p>另外，我们想要通过用 <code>numberOfPairsOfCards</code> 和 <code>cardContentFactory</code> 来初始化 <strong>Model</strong> (MemoryGame.swift)。因此我们先需要自定义 <strong>Model</strong> 的初始化函数。（这两个参数分别代表卡片数，以及通过卡片索引获取卡片内容的函数）</p>
<h5 id="Model-初始化器"><a href="#Model-初始化器" class="headerlink" title="Model 初始化器"></a><code>Model</code> 初始化器</h5><h6 id="1-For-循环"><a href="#1-For-循环" class="headerlink" title="1. For 循环"></a><strong>1. For 循环</strong></h6><p>我们想要对每张原卡片，卡片组中都会有两张存在。我们可以使用 <code>_</code> 来忽略循环的索引。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryGame.swift</span></span><br><span class="line"><span class="keyword">for</span> pairIndex <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numberOfPairsOfCards &#123;</span><br><span class="line">    cards.append(<span class="type">XXXX</span>)</span><br><span class="line">    cards.append(<span class="type">XXXX</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Use _ to ignore the pairIndex</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numberOfPairsOfCards &#123;</span><br><span class="line">    cards.append(<span class="type">XXXX</span>)</span><br><span class="line">    cards.append(<span class="type">XXXX</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XXXX</code> 代表的是 <code>cardContentFactory</code> 通过 <code>pairIndex</code> 索引获取到的卡片内容。下边会讲如何使用闭包来实现该函数。</p>
<h6 id="2-闭包语法"><a href="#2-闭包语法" class="headerlink" title="2. 闭包语法"></a><strong>2. 闭包语法</strong></h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">numberOfPairsOfCards</span>: <span class="type">Int</span>, <span class="params">cardContentFactory</span>: (<span class="type">Int</span>) -&gt; <span class="type">CardContent</span>) &#123;</span><br><span class="line">        cards <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add numberOfParisOfCards x 2 cards</span></span><br><span class="line">        <span class="keyword">for</span> pairIndex <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numberOfPairsOfCards &#123;</span><br><span class="line">            <span class="keyword">let</span> content <span class="operator">=</span> cardContentFactory(pairIndex)</span><br><span class="line">            cards.append(<span class="type">Card</span>(content: content))</span><br><span class="line">            cards.append(<span class="type">Card</span>(content: content))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在-ViewModel-中初始化-Model-变量"><a href="#在-ViewModel-中初始化-Model-变量" class="headerlink" title="在 ViewModel 中初始化 Model 变量"></a>在 <code>ViewModel</code> 中初始化 <code>Model</code> 变量</h5><p>接下来，我们需要初始化 <code>model</code> 变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">createCardContent</span>(<span class="params">forPairAtIndex</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(</span><br><span class="line">        numberOfPairsOfCards: <span class="number">4</span>,</span><br><span class="line">        cardContentFactory: createCardContent</span><br><span class="line">    )</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MemoryGame</code> 初始化器的第二个参数需要传入一个接受整数并返回字符串的函数。<code>createCardContent</code> 是一个接受整数并返回字符串的函数，因此我们可以将它传入。</p>
<p>我们可以使用<strong>闭包语法</strong>让它更变得更简洁一些：将 <code>createCardContent</code> 函数内容移入类初始化参数 <code>cardContentFactory</code> 后，并将函数大括号 <code>&#123;&#125;</code> 替换为 <code>in</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(</span><br><span class="line">        numberOfPairsOfCards: <span class="number">4</span>,</span><br><span class="line">        cardContentFactory: &#123; (index: <span class="type">Int</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][index]</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"><span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<strong>类型推断</strong>，输入参数为 <code>Int</code> 类型，我们可以省略类型声明，如下：</p>
<blockquote>
<p>可按住 option，并 click 查看 <code>Index</code> 推断的类型为 <code>Int</code>。类型推断在第二节有说明：<a href="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/" title="Stanford cs193p 02 | More SwiftUI">Stanford cs193p 02 | More SwiftUI</a></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(</span><br><span class="line">        numberOfPairsOfCards: <span class="number">4</span>,</span><br><span class="line">        cardContentFactory: &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][index]</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"><span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，由于 <code>cardContentFactory</code> 是这个函数的最后一个参数，我们可以使用<strong>尾随闭包</strong>：</p>
<blockquote>
<p>尾随闭包在第二节笔记中有说明：<a href="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/" title="Stanford cs193p 02 | More SwiftUI">Stanford cs193p 02 | More SwiftUI</a></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="1-0"><a href="#1-0" class="headerlink" title="1. $0"></a><strong>1. $0</strong></h6><p>$0 是一个用于表示第一个参数的特殊占位符，这里可使用 <code>$0</code> 替代 <code>index</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][index]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="comment">// If we use $0</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; <span class="variable">$0</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][<span class="variable">$0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h6 id="2-静态变量和函数"><a href="#2-静态变量和函数" class="headerlink" title="2. 静态变量和函数"></a><strong>2. 静态变量和函数</strong></h6><p>倘若，我们还想简化这个类的初始化，想将这个表情数组提取为一个变量 <code>emojis</code> 使用， 以下代码 XCode 会报错：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>错误信息是 “Cannot use instance member ‘emojis’ within property initializer; property initializers run before ‘self’ is available”. <code>emojis</code> 和 <code>model</code> 被称为 property initializer。<strong>由于 property initialized 的运行顺序是不确定的 (不是源代码的顺序)，我们可能会先初始化 model，但此时 emojis 还未被初始化，因此不能使用一个初始化变量去初始化另一个。</strong></p>
<p>那么怎么解决呢？</p>
<p><strong>第一种方法：将 emojis 设置为一个全局变量</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// EmojiMemoryGame.emojis[pairIndex]</span></span><br><span class="line">        <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>但这会污染命名空间，可能会与其他变量或常量发生命名冲突，难以调试。而且全局变量可以在任意位置被修改，<code>View</code> 和 <code>Model</code> 中都可以修改，导致代码很难理解，因为变量的状态可能在不知情的情况下被修改。</p>
<p>所以为了使它具有可封装性，还是得将它放回类 <code>class</code> 中。</p>
<p><strong>第二种方法：使用关键字 <code>static</code> 来解决</strong></p>
<p>我们可以使用关键字 <code>static</code> 来解决这个问题。这个关键字可以让 <code>emojis</code> 变为全局变量 (事实上被称为 type variable) 但仅限于这个类的内部访问。而且全局变量会被优先初始化，不用担心初始化变量的顺序问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">EmojiMemoryGame</span>.emojis[pairIndex]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p><code>private</code> 则可以讲这个变量限制在 <code>class</code> 内部使用，外部无法直接访问或修改。此时不再需要 <code>EmojiMemoryGame</code> 来调用 <code>emojis</code>，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// EmojiMemoryGame.emojis[pairIndex]</span></span><br><span class="line">        <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：现在 <code>emojis</code> 的全名其实是 <code>EmojiMemoryGame.emojis</code>.</p>
</blockquote>
<p>我们现在将上面的变量变成一个函数，然后存在 model 里：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> createMemoryGame()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">createMemoryGame</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>会有一堆错误信息。</p>
<p>我们需要将函数标记为 <code>static</code> 并增加返回类型。<strong>Swift 是不可以推断返回类型的。</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">createMemoryGame</span>() -&gt; <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> createMemoryGame()</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h6 id="3-“-thing”"><a href="#3-“-thing”" class="headerlink" title="3. “.thing”"></a><strong>3. “.thing”</strong></h6><blockquote>
<p>此处 <code>.thing</code> 是补充说明 <code>privat static</code>，并不涉及 <code>ViewModel</code> 和 <code>Model</code> 的实现</p>
</blockquote>
<p>当我们看到 “.一个东西”时, 它只有可能是静态变量或者枚举类型 <code>enum</code>。如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ContentView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>))]) &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line">.foregroundColor(.orange)</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们在代码中发现了一个 <code>.orange</code> ，它实际与 <code>Color.orange</code> 的含义完全相同。我们再打开 Swift 的开发者文档：<br><img src="/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/cs193p04_static-let-orange.jpg"></p>
<p><code>.orange</code>、<code>.pink</code> 和 <code>.purple</code> 都是静态 <code>static</code> 变量。</p>
<h4 id="2-2-3-问题解决：数组不能超出索引"><a href="#2-2-3-问题解决：数组不能超出索引" class="headerlink" title="2.2.3 问题解决：数组不能超出索引"></a>2.2.3 问题解决：数组不能超出索引</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">createMemoryGame</span>() -&gt; <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们访问数组时不能超出索引，因此需要新增一些逻辑。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">createMemoryGame</span>() -&gt; <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> emojis.indices.contains(pairIndex) &#123;</span><br><span class="line">                <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;⁉️&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们同时希望有至少 4 张卡：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">numberOfPairsOfCards</span>: <span class="type">Int</span>, <span class="params">cardContentFactory</span>: (<span class="type">Int</span>) -&gt; <span class="type">CardContent</span>) &#123;</span><br><span class="line">        cards <span class="operator">=</span> []</span><br><span class="line">        <span class="comment">// add numberOfParisOfCards x 2 cards</span></span><br><span class="line">        <span class="keyword">for</span> pairIndex <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="built_in">max</span>(<span class="number">2</span>, numberOfPairsOfCards) &#123;</span><br><span class="line">            <span class="keyword">let</span> content <span class="operator">=</span> cardContentFactory(pairIndex)</span><br><span class="line">            cards.append(<span class="type">Card</span>(content: content))</span><br><span class="line">            cards.append(<span class="type">Card</span>(content: content))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-在-View-中使用-ViewModel"><a href="#2-3-在-View-中使用-ViewModel" class="headerlink" title="2.3 在 View 中使用 ViewModel"></a>2.3 在 View 中使用 ViewModel</h3><blockquote>
<p>注意: 我们将 ContentView.swift 文件重命名为了 EmojiMemoryGameView.swift</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>))]) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(emojis.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">                    .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> content: <span class="type">String</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                base.fill(.white)</span><br><span class="line">                base.strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(content).font(.largeTitle)</span><br><span class="line">            &#125;</span><br><span class="line">            .opacity(isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            base.fill().opacity(isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>现在需要循环卡片。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>))]) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(viewModel.cards.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(card: viewModel.cards[index])</span><br><span class="line">                    .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> card: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                base.fill(.white)</span><br><span class="line">                base.strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(card.content).font(.largeTitle)</span><br><span class="line">            &#125;</span><br><span class="line">            .opacity(card.isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            base.fill().opacity(card.isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>如果我们现在想要查看卡片的正面，只需要更改 Model 即可。（<code>MemorizeGame.swift</code> 文件）</p>
<h4 id="2-3-1-CardView-Struct-优化"><a href="#2-3-1-CardView-Struct-优化" class="headerlink" title="2.3.1 CardView Struct 优化"></a>2.3.1 CardView Struct 优化</h4><p>我们还可以优化一下 CardView。调用时需要写 <code>card:</code> 很麻烦：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">CardView</span>(card: viewModel.cards[index])</span><br></pre></td></tr></table></figure>

<p>我们可以创建自己的初始化函数<code>init</code>忽略函数标签。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>))]) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(viewModel.cards.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(viewModel.cards[index])</span><br><span class="line">                    .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> card: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.card <span class="operator">=</span> card</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-放大-Emoji"><a href="#2-3-2-放大-Emoji" class="headerlink" title="2.3.2 放大 Emoji"></a>2.3.2 放大 Emoji</h4><p><img src="/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/cs193p04_biggerEmoji.png"></p>
<h3 id="2-4-View-和-ViewModel-关联优化"><a href="#2-4-View-和-ViewModel-关联优化" class="headerlink" title="2.4 View 和 ViewModel 关联优化"></a>2.4 <code>View</code> 和 <code>ViewModel</code> 关联优化</h3><h4 id="2-4-1-MARK-Intents"><a href="#2-4-1-MARK-Intents" class="headerlink" title="2.4.1 MARK: - Intents"></a>2.4.1 <code>MARK: - Intents</code></h4><p>当我们使用 <code>MAKR: - XXX</code> 时， <code>-</code> 可以在 Swift 中看起来有一条线一样，如下图。</p>
<p><img src="/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/cs193p04_mark.png"></p>
<h4 id="2-4-2-洗牌"><a href="#2-4-2-洗牌" class="headerlink" title="2.4.2 洗牌"></a>2.4.2 洗牌</h4><h5 id="修改-View-和-ViewModel"><a href="#修改-View-和-ViewModel" class="headerlink" title="修改 View 和 ViewModel"></a>修改 View 和 ViewModel</h5><p>实现（修改） ViewModel:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">      <span class="operator">...</span></span><br><span class="line">    <span class="comment">// MARK: - Intents</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shuffle</span>() &#123;</span><br><span class="line">        model.shuffle()</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">      <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现（修改）View:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">ScrollView</span> &#123;</span><br><span class="line">                cards</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Shuffle&quot;</span>) &#123;</span><br><span class="line">                viewModel.shuffle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h5 id="mutating"><a href="#mutating" class="headerlink" title="mutating"></a>mutating</h5><p>我们需要让 Model 支持洗牌的操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shuffle</span>() &#123;</span><br><span class="line">        cards.shuffle()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>但是，<code>self (Model)</code> 是不可更改的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">shuffle</span>() &#123;</span><br><span class="line">        cards.shuffle()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>任何函数需要修改 Model 必须要被标记 <strong>mutating</strong> 关键字，因为这会造成写时复制（copy on write）。</p>
<h5 id="Reactive-UI"><a href="#Reactive-UI" class="headerlink" title="Reactive UI"></a>Reactive UI</h5><p><code>@ObservableObject</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">      <span class="meta">@Published</span> <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> createMemoryGame()</span><br><span class="line">      <span class="operator">...</span></span><br><span class="line">    <span class="comment">// MARK: - Intents</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shuffle</span>() &#123;</span><br><span class="line">        model.shuffle()</span><br><span class="line">        objectWillChange.send()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objectWillChange.send()</code> 会通知 UI (View)，有些东西将要变了。 <code>@Published</code> 则在一些东西变动后, 说一些东西已经变了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">EmojiMemoryGame</span> <span class="operator">=</span> <span class="type">EmojiMemoryGame</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">ScrollView</span> &#123;</span><br><span class="line">                cards</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Shuffle&quot;</span>) &#123;</span><br><span class="line">                viewModel.shuffle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们也需要给我们的 <code>viewModel</code> 变量添加 <code>@ObservedObject</code> 。此处 <code>@ObservedObject</code> 的作用会观察 <code>EmojiMemoryGame</code> 中的 <code>@Published</code> 变量变化，如果发生变化了，则会重新渲染 UI。</p>
<p><strong>重要提示：</strong> 有一个 <code>@ObservedObject</code> 然后赋值一些东西是<strong>非常不好</strong>的习惯。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">EmojiMemoryGame</span> <span class="operator">=</span> <span class="type">EmojiMemoryGame</span>()</span><br></pre></td></tr></table></figure>

<p><strong>正确</strong> 的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">EmojiMemoryGame</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="type">Preview</span> &#123;</span><br><span class="line">	<span class="comment">//此处初始化 viewModel 变量，来进行预览</span></span><br><span class="line">    <span class="type">EmojiMemoryGameView</span>(viewModel: <span class="type">EmojiMemoryGame</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还需要修改 App：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeApp.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemorizeApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化 viewModel 对象</span></span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">var</span> game <span class="operator">=</span> <span class="type">EmojiMemoryGame</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">EmojiMemoryGameView</span>(viewModel: game)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@StateObject</code> 意思是你不能和其他 <code>View</code> 共享这个对象。</p>
<h5 id="续第五节课：-ObservedObject-和-StateObject-区别"><a href="#续第五节课：-ObservedObject-和-StateObject-区别" class="headerlink" title="续第五节课：@ObservedObject 和 @StateObject 区别"></a>续第五节课：<code>@ObservedObject</code> 和 <code>@StateObject</code> 区别</h5><p><strong>1. 示例（非课件内容）</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> value <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ParentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> counter <span class="operator">=</span> <span class="type">Counter</span>() <span class="comment">// 由父视图负责创建和管理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ChildView</span>(counter: counter) <span class="comment">// 将 ObservableObject 传递给子视图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChildView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> counter: <span class="type">Counter</span> <span class="comment">// 观察父视图传递过来的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Counter: <span class="subst">\(counter.value)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increment&quot;</span>) &#123;</span><br><span class="line">                counter.value <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>ParentView</code></strong> 创建并管理 <code>Counter</code> 的生命周期。</li>
<li><strong><code>ChildView</code></strong> 使用 <code>@ObservedObject</code> 观察传入的 <code>Counter</code> 实例，但不负责管理其生命周期。</li>
</ul>
<p>使用 <code>@StateObject</code> 和 <code>@ObservedObject</code> 的核心在于对<strong>生命周期的理解</strong>，确保在合适的上下文中管理和观察数据。</p>
<p><strong>2. 总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>@ObservedObject</code></th>
<th><code>@StateObject</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>负责实例创建</strong></td>
<td>否：只观察传入的 <code>ObservableObject</code></td>
<td>是：负责创建并管理 <code>ObservableObject</code> 的生命周期</td>
</tr>
<tr>
<td><strong>生命周期管理</strong></td>
<td>不管理，依赖于外部实例的生命周期</td>
<td>自动管理，当视图销毁时，<code>ObservableObject</code> 也销毁</td>
</tr>
<tr>
<td><strong>初始化时机</strong></td>
<td>外部传入实例，必须在外部已创建</td>
<td>仅在视图首次初始化时创建一次</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>子视图：观察由父视图传递的 <code>ObservableObject</code> 实例</td>
<td>父视图：创建并管理自己的 <code>ObservableObject</code> 实例</td>
</tr>
<tr>
<td><strong>重复渲染</strong></td>
<td>每次视图刷新时，观察相同的实例</td>
<td>不会在视图刷新时重复创建 <code>ObservableObject</code></td>
</tr>
</tbody></table>
<ul>
<li><code>@StateObject</code> 适用于当前视图需要自己创建并管理 <code>ObservableObject</code> 实例的生命周期，常用于父视图或独立视图。</li>
<li><code>@ObservedObject</code>适用于观察由外部传递的 <code>ObservableObject</code>，常用于子视图。</li>
<li><code>@ObservedObject</code> 和 <code>@StateObject</code> 都是用于观察 <code>ObservableObject</code> 的属性包装器，但它们有不同的使用场景和生命周期管理方式。</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
</search>
